\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{booktabs}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{regexpatch}
\makeatletter
\usepackage{letltxmacro}
\usepackage{aligned-overset}

\usepackage{hyperref}
\usepackage{cleveref}

\usepackage{nowidow}

\usepackage{titling}
\usepackage{braket}
\usepackage{minted}
\usepackage[margin=1in]{geometry}
\usepackage[super]{nth}

\setlength\parindent{0pt}

\title{CMSC32700 Project Report: Verifying Wiesner's quantum money using SQIR}
\author{Adrian E. Lehmann}
\date{Jun 4, 2020}

\begin{document}

\maketitle

\section{Introduction}
At the moment we have many quantum circuit designs, for transmitting and encoding information but none of them have been tried to be verified using SQIR~\cite{SQIR}. 
Hence in this project we will try to verify a simple $n$-qubit quantum key distribution protocol ``Wiesner's quantum money''~\cite{wiesner} which we will examine close in \cref{sec:wiesner}. 
We will then proceed to prove a few interesting properties of the scheme.
The mechanization of said proofs will be described in \cref{sec:proof-impl}.

\section{Background}

\subsection{Coq, QWIRE, SQIR}
To formally verify the algorithm we will be using a quantum formal verification stack based on the coq proof assistant~\cite{coq}.
On top of coq, there are two main libraries that we will be using: QWIRE~\cite{QWIRE} and SQIR~\cite{SQIR}.
QWIRE is a quantum programming language that has been embedded into Coq and SQIR is a fromal verification framework built on top of QWIRE.
While SQIR was originally intended as an intermediate representation for a verified quantum compiler (VOQC~\cite{voqc}), it has been used to prove various algorithms, such as Deutsch-Josza's~\cite{deutsch} or Shor's~\cite{shor} algorithm.


\subsection{Wiesner's qunatum money}\label{sec:wiesner}

Wiesner's quantum money proposed by Stephen Wiesner in 1983~\cite{wiesner}, is a quantum verification scheme that intends to encode an $n$ bit integer. 
Given two parties, Alice and Bob, Alice will encode the n bit integer by choosing a basis such that each bit of the integer will either be encoded to quantum $\ket{1}$ in the basis $\ket{0}, \ket{1}$ or the basis $\ket{-},\ket{+}$.
Physically this corresponds to choice of orthogonal polarization.
Bob will then decode the integer using his basis.
Using the no-cloning property, it follows that when Bob measures to get the classical information, he will certainly get the correct output if his basis is equal.
If his basis does not match, he will have a chance of $\frac{1}{2^{n_{diff}}}$ getting the correct result, where $n_{diff}$ is the number of bits his basis differs from Alice's.
It follows that his chance getting the correct output using a random is $(\frac{3}{4})^n$.

In the context of money, the $n$-bit integer would be a serial number, Alice the central bank, and Bob a malicious \nth{3} party trying to copy money.
While the central bank can validate bills with a given serial numbers, while the \nth{3} party would be unable to decode the bill to get a valid serial number to copy.

\section{Proof Implementation}\label{sec:proof-impl}
We implement a proof to show that Wiesner's quantum money scheme for any $n$ qubits will yield the correct state with probability $1$, if Alice and Bob have the same base, and will only yield the correct output with probability $\frac{1}{2^{n_{diff}}}$, where $n_{diff}$ is the number of bits that are different in Bob's and Alice's base. In the following, we will discuss the steps we took to prove these conjecture. The accompanying code can be found on GitHub\footnote{\url{https://github.com/adrianleh/SQIR/blob/main/examples/Wiesner.v}}.

\subsection{Circuit design}

Our circuit will operate on each qubit independently (i.e. one qubit only influeces the ouput of itself, and the circuit does not require any ancilla), where each qubit will have a Pauli $X$-Gate classically controlled (cc) by a data bit, followed by two Hadamard gates, clasically controlled by Alice's and Bob's basis bits.

Given an input of $\ket{0}$, this will if the data bit is $1$, transform to $\ket{1}$, and then use Alice's basis bit to either stay in the basis $\ket{0},\ket{1}$ basis, or rotate into the $\ket{+},\ket{-}$ basis. 
Bob's basis bit will then control the rotation bob applies to attempt to restore the original basis.

We will now proceed to describing the circuit for $n$ qubits. 
For this we will assume, we have $3$ $n$-sized arrays $data, ab, bb$, containing classical data, basis bits for Alices, and basis bits for Bob respectively.

We designed the circuit inductively, row by row using, such that for our circuit is defined as
$$C(n) = \begin{cases}
I_1&, n=0\\
C(n-1) \otimes R(n)&, n>0
\end{cases}$$,
where $R$ is the function constructing a row
$$R(n) = \begin{cases}X&, data_n = 1\\ I_2&, \text{else}\end{cases} \times \begin{cases}H&, ab_n = 1\\ I_2&, \text{else}\end{cases} \times \begin{cases}H&, bb_n = 1\\ I_2&, \text{else}\end{cases}$$

This is implemented in Coq by the definitions \texttt{circuit'\_qubit\_\_non\_meas} ($\hookrightarrow R(n)$) and \texttt{circuit'}.

An implementation note is that instead of tensoring the constructed unitaries, we chose to append unitaries of dimension $n$, where we solely padded the unitaries to move our operations to the correct qubit.

The coq implementation of this can be seen in \cref{fig:coq-circuit}
\begin{figure}[h]
    \centering
    \begin{minted}[linenos,tabsize=1,breaklines]{coq}
Notation bit_string := (list bool).
Notation combined_bit_string := (list (bool * bool * bool)).    
Definition alice_bit_manip (base : bool) (data : bool) (n i : nat) : base_ucom n :=
  (if data then X i else SKIP);
  (if base then H i else SKIP).
Definition bob_bit_manip (base : bool) (n i : nat) : base_ucom n :=
  if base then H i else SKIP.
Definition circuit'_qubit_i_non_meas (ad ab bb : bool) (n i : nat) : base_ucom n := 
  alice_bit_manip ab ad n i; bob_bit_manip bb n i.

 
Fixpoint circuit'_helper (l : combined_bit_string) (n : nat) (i : nat) : base_ucom n :=
  match l with
    | [] => SKIP
    | ((ad,ab),bb)::l' => circuit'_helper l' n (S i); circuit'_qubit_i_non_meas ad ab bb n i
  end.
    
Definition circuit' (alice_data alice_base bob_base : bit_string) (n : nat) :=
  circuit'_helper (zip (zip alice_data alice_base) bob_base) n 0.
    \end{minted}
    \caption{The QWIRE definition for our circuit}
    \label{fig:coq-circuit}
\end{figure}

We can see the resulting construction in \cref{fig:circuit}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{res/Wiesner.pdf}
    \caption{Wiesner's quantum money for $n$ qubits}
    \label{fig:circuit}
\end{figure}

While some both of these algorithms use $n$ qubits, and use the library feature \texttt{npar} to replicate their circuits, we cannot use this, since each qubit of our circuit depeneds on different classical controls. This fact will complicate our proof and cause us to require the work of \cref{sec:circuit-growth}.

Henceforth we will assume the input to the circuit is initialized to $\ket{\underbrace{0...0}_n}$.

We note that this design is our second iteration, where in the first iteration instead of grouping operations by qubit, we tried grouping them by type (i.e., grouping all the $X$, all of Alice's Hadamard gates, and all of Bob's Hadamard gates) and then concatenating but that turned out to make proof more difficult.

\subsection{Individual qubit correctness}\label{sec:qubit-correct}
We prove that for any individual qubit our construction yields 
$Q(data,ab,bb) = \begin{cases} 
\ket{0}&, data=0 \wedge ab=bb\\
\ket{1}&, data=1 \wedge ab=bb\\
\ket{-}&, data=0 \wedge ab \neq bb\\
\ket{+}&, data=1 \wedge ab \neq bb
\end{cases}
$

This proof basically follows directly from the definitions of Pauli $X$ and Hadamard, and the self-inverse property of Hadamard.

In our implementation we proved this through the four lemmata, one for each of the cases listed above.
Though we note that the actual coq lemma prove that the implementation yields gates that trivally transform $\ket{0}$ into said states, instead of proving states directly. 
This proof-design was chosen as operations on unitaries are better supported in SQIR.

\subsection{Inductive circuit growth}\label{sec:circuit-growth}

Likely the most important, yet most challenging lemma to prove was about circuit growth, in the inductive proof that we will see in \cref{sec:circuit-correct}, we will need to able to reason about growing circuits.
Specifically, we will require the following theorem:
\begin{minted}[linenos,tabsize=1,breaklines,escapeinside=||,mathescape=true]{coq}
Theorem circuit'_helper_growth: forall n l, (length l = S n) ->  uc_eval(circuit'_helper l (S (S n)) 1) =  I 2 |$\otimes$| uc_eval (circuit'_helper l (S n) 0).
\end{minted}
which essentially says for any $n>0$ building step $1$ in the inductive construction of a circuit of size $n+1$, the current step is equal to tensoring $I_2$ to the \nth{0} step in building a circuit of size $n$.

Though proving this theorem by itself turned out to be impossible and we resorted to proving a stronger notion where we prove that for a circuit and $n>0$ of size $n+i$, the evaluation of the circuit at step $i+1$ is equal to $I_{i+1}$ tensored with the evaluation of the \nth{0} step of a circuit with size $n$
\begin{minted}[linenos,tabsize=1,breaklines,escapeinside=||,mathescape=true]{coq}
Lemma circuit'_helper_growth_i: forall n l i, (length l = S n) -> uc_eval(circuit'_helper l ((S i) + (S n)) (S i)) =  I (2^(S i)) |$\otimes$| uc_eval (circuit'_helper l (S n) 0).
\end{minted}

The reason we note this property is because this is how we were able to inductively reason about a heterogenous circuit of size $n$ which had been inductively defined.
This theorem is the foundation of any useful reasoning about this circuit.

We note that this circuit growth lemma could likely be generalized to all circuits consisting solely of unitary gates, where each qubit operates independently, and the circuit itself is defined by the same structure of inductive definition. Though this generalization had to be forgone in the interest of time.

A further potentially general-enough-to-be-extracted lemma that we used in the process is:
\begin{minted}[linenos,tabsize=1,breaklines,escapeinside=||,mathescape=true]{coq}
Lemma kron_dist_mult_id : forall n m (B C : Square m) , (I n) |$\otimes$| (B |$\times$| C) = ((I n) |$\otimes$| B) |$\times$| ((I n) |$\otimes$| C).
\end{minted}
\subsection{Inductive circuit correctness}\label{sec:circuit-correct}
Our goal is to prove that given any data and any bases bitstring(s) that our algorithm yields we expected output.

We define our expected output inductively as follows:
$$O(n,data,ab,bb) = \begin{cases}I_1&,n=0\\ Q(data[n],ab[n],bb[n]) \otimes O(n-1, data, ab,bb)&, n>0\end{cases}$$

To prove this correct we shall proceed inductively. Our base case has been shown in \cref{sec:qubit-correct}.

To perform the inductive step we will separate the new added qubit from the remaining construction and then using our inductive circuit growth property, we will show that given individual qubit correctness the entire circuit is correct.

The synopsis of the relevant coq code can be seen in \cref{fig:correct-main-circuit}
\begin{figure}[h]
    \centering
\begin{minted}[linenos,tabsize=1,breaklines,escapeinside=||,mathescape=true]{coq}
Definition q_bool (b : bool) := if b then |$\ket{1}$| else |$\ket{0}$|.

Definition output_state_qubit_i (d ab bb : bool) :=
  if (eqb ab bb) then
    q_bool d
  else
    hadamard |$\times$| q_bool d.

Fixpoint output_state n (l : combined_bit_string) : Vector (2 ^ n) :=
  match l with
  | [] => I 1
  | (d, ab, bb)::l' => output_state_qubit_i d ab bb |$\otimes$| output_state (n-1) l'
  end.
  
Theorem circuit'_output_correct: forall n data ab bb, (length data = S n) -> (length ab = S n) -> (length bb = S n) -> (uc_eval (circuit' data ab bb (S n))) |$\times$| initial_state (S n) = output_state (S n) (zip (zip data ab) bb).
\end{minted}
    \caption{Synopsis of relevant coq statments for correctness}
    \label{fig:correct-main-circuit}
\end{figure}

\subsection{Individual qubit probability}\label{sec:qubit-prob}

What we can now prove using the construction of the indivdual qubits in \texttt{output\_state\_qubit\_i} (as seen in \cref{fig:correct-main-circuit}) that given $ab=bb$ we get upon measurement the expected result with certainty.
Whereas, if $ab\neq bb$, we can use the properties of hadamard to easily show we get the expected outputwith probability $\frac{1}{2}$.

\subsection{Inductive circuit probability}\label{circuit-prob}
Using the fact that from \cref{sec:circuit-correct}, that we now have a vector representation of our evaluation, we can now prove facts about the execution without requiring deep circuit manipulation.

Using the definition of \texttt{output\_state} (as seen in \cref{fig:correct-main-circuit}), we can easily prove that our circuit yields our target state with probability $1$. 
Our target state hereby is defined as what we would intuitively expect:
$$T(n,data) = \begin{cases}
I_1&, n =0\\
\begin{cases}
\ket{1}&, data[n] = \texttt{true}\\
\ket{0}&, data[n] = \texttt{false}
\end{cases} \otimes T(n-1,data)&, n>0
\end{cases}$$

Using the fact that $T(n,data)$ is always a unit vector we can then prove certainty of correct output inductively using SQIR's lemma \texttt{probability\_of\_outcome\_is\_norm}, and a lemma to extract the newly added element from the resulting norm \texttt{norm\_kron}\footnote{This is another lemma that seems generally useful and could be extracted}. 

The other, perhaps more challenging undertaking was to show that given any two bases, the probability of getting \texttt{target\_state} upon measurement is $(\frac{1}{2})^{n_{diff}}$, where $n_{diff}$ is the number of non equal bits in the two bases. To prove this, we use the facts we established in \cref{sec:qubit-prob}, using the same lemmata as in the proof for equal bases to inductively prove the our conjecture.

The relevant coq code for this section can be seen in \cref{fig:circuit-prob}.

\begin{figure}
    \centering
\begin{minted}[linenos,tabsize=1,breaklines,escapeinside=||,mathescape=true]{coq}

Notation target_state_qubit_i := q_bool.

Fixpoint target_state n (data: bit_string) : Vector (2^n) :=
  match data with
  | [] => I 1
  | d::data' => target_state_qubit_i d |$\otimes$| target_state (n-1) data'
  end.
  
Theorem circuit'_same_base_correct: forall n data base, (length data = S n) -> (length base = S n) -> (uc_eval (circuit' data base base (S n))) |$\times$| initial_state (S n) = target_state (S n) data. 

Lemma target_state_norm: forall n data, (length data = S n) -> norm ((target_state (S n) data)|$\dagger$| |$\times$| (target_state (S n) data)) = 1.
Lemma norm_kron: forall (A : Vector 1) (B : Vector 1), @norm (1) (A |$\otimes$| B) = (@norm 1 A * @norm 1 B)%R.
(* The following lemma already existed in the SQIR codebase *)
Lemma probability_of_outcome_is_norm : forall {d} (|$\phi$| |$\psi$| : Vector d),
  probability_of_outcome |$\phi$| |$\psi$| = ((norm (|$\phi\dagger \times \psi$|)) ^ 2)%R.

Theorem probibility_correct: forall n data base, (length data = S n) -> (length base = S n) -> probability_of_outcome (uc_eval (circuit' data base base (S n)) |$\times$| initial_state (S n)) (target_state (S n) data) = 1%R.

Theorem probibility_incorrect: forall n n_diff data ab bb, (length data = S n) -> (length ab = S n) -> (length bb = S n) -> count_diff ab bb = n_diff -> probability_of_outcome (uc_eval (circuit' data ab bb (S n)) |$\times$| initial_state (S n)) (target_state (S n) data) = ((1/2)%R^n_diff)%R.
\end{minted}
    \caption{Synopsis of coq code from statements about probability}
    \label{fig:circuit-prob}
\end{figure}

\section{Discussion}


\section{Conclusion}


\bibliographystyle{IEEEtran}
\bibliography{bib}

\end{document}
